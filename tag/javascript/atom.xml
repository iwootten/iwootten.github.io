<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
   
   	<title>ianwootten.co.uk - Tag: javascript</title>
   
   <link>http://ianwootten.co.uk</link>
   <description>I'm a Web Developer  working at <a href="http://niftydigits.com">Nifty Digits</a> in Cardiff, UK. Here, I enjoy talking code - mostly javascript. I'm <a href="http://twitter.com/iwootten">@iwootten</a> on twitter.</description>
   <language>en-us</language>
   <managingEditor>I.M.Wootten</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />

    
	  <item>
        <title>The Problem with Full Stack JS Applications</title>
        <link>http://ianwootten.co.uk/2013/04/03/the-problem-with-full-stack-js-applications</link>
		<author>I.M.Wootten<</author>
		<pubDate>2013-04-03T00:00:00+01:00</pubDate>
		<guid>http://ianwootten.co.uk/2013/04/03/the-problem-with-full-stack-js-applications</guid>
		<description><![CDATA[
		   <p>Whilst node.js heralded an era of being able to use a single language for both server and client side development, nobody mentioned the confusion such an approach could cause. It’s inevitable that there’s going to be similarities in code that constructs data on the server and that which presents it on the client. The fact that the two are written in the same language and the structure of them is so tightly coupled can make it easy to lose track of where you are and what you’re doing when knee deep in code.</p>

<p>Having primarily been using a full js stack (express on the server, backbone on the client) for side projects over the last year or so, I’ve certainly found myself tied up in this kind of knot. For example, if I’m looking at event.js, which represents an event on a calendar it could be the server event representation, used as an accessor for a db or a client side backbone model presenting the events attributes as part of a view. Usually (if you’re using a sensible class naming scheme) it is enough to know the file (.php or .js) within which you’re working and if that’s not enough, then the language syntax usually is a dead giveaway for where you are in your codebase. But this isn’t the case when working in one language. My guess is you’re going to have to take a second glance in order to figure out where you are, which isn’t a big issue, but is frustrating.</p>

<p>Currently my apps typically are structured like this:</p>

<p>server.js (Main node/express file)<br />
-lib (Classes for DB Calls)<br />
-node_modules (Node requires)<br />
-public (Client backbone app)<br />
    -css<br />
    -images<br />
    -js<br />
        -lib (Backbone and other dependencies)<br />
        -collections<br />
        -models<br />
        -templates<br />
        -views<br />
-routes (Contains the main express routes)</p>

<p>But I actually think the following is a better approach:</p>

<p>-server<br />
    server.js<br />
    -lib<br />
    -node_modules<br />
    -routes<br />
-client (Renamed from public)<br />
    -css<br />
    -images<br />
    -js<br />
        -lib<br />
        -collections<br />
        -models<br />
        -templates<br />
        -views</p>

<p>At least with the second approach, it is easier to have a clear idea of where to find classes on first opening them. Unfortunately, this doesn’t however solve my problem of moving between server side and client logic and pausing for a moment before realising I am where I need to work. This is a first world problem for which I don’t believe there is a solution.</p>

		]]></description>
	  </item>
    
  </channel>
</rss>